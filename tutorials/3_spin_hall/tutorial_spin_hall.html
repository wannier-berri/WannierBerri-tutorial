

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WannierBerri advanced tutorial - Spin Hall conductivity &mdash; Wannier Berri 1.6.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/style.css?v=88c5e859" />
      <link rel="stylesheet" type="text/css" href="../../_static/nbsphinx-code-cells.css?v=2aa19091" />

  
    <link rel="shortcut icon" href="../../_static/WB-logo.ico"/>
    <link rel="canonical" href="https://tutorial.wannier-berri.org/tutorials/3_spin_hall/tutorial_spin_hall.html" />
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=d6a008b6"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Wannier Berri 1.6.1 documentation"
          href="../../_static/opensearch.xml"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #009C46" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/tutorial.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../1_basic/tutorial-wb-basic-solution.html">Basic tutorial: Interpolating bands, Berry curvatures, and integrating them</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2_fermi_sea_vs_fermi_surface/solution/tutorial_sea_vs_surface_solution.html">WannierBerri advanced tutorial - Fermi surface and Fermi sea calculation of the Berry curvature dipole</a></li>
<li class="toctree-l1"><a class="reference internal" href="solution/tutorial_spin_hall.html">Spin Hall conductivity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4_DIY/tutorial-wb-DIY-solution.html">DIY tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5_symmetrization/tutorial_symmetrization-solution.html">Symmetrization of Wannier Hamiltonian and matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../6_wannierisation/wannierise.html">Wannierisation (including SAWF)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../7_find_projections/find_projections.html">Finding initial projections based on symmetry indicators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../8_GPAW/1.diamond/diamond.html">GPAW + WannierBerri: spinless bandstructure (diamond)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../8_GPAW/2.Fe/bccFe.html">GPAW + WannierBerri: Magnetism and spin-orbit coupling (bcc Fe)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../8_GPAW/3.MnTe/mnte.html">GPAW + WannierBerri: Altermagnet MnTe</a></li>
</ul>

    <a href="genindex.html">Index</a>
    <a href="http://wannier-berri.org">Back to Wannier-Berri.org</a>
  
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #009C46" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Wannier Berri</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">WannierBerri advanced tutorial - Spin Hall conductivity</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="WannierBerri-advanced-tutorial---Spin-Hall-conductivity">
<h1>WannierBerri advanced tutorial - Spin Hall conductivity<a class="headerlink" href="#WannierBerri-advanced-tutorial---Spin-Hall-conductivity" title="Link to this heading"></a></h1>
<p>author: Jae-Mo Lihm (<a class="reference external" href="mailto:jaemo&#46;lihm&#37;&#52;&#48;gmail&#46;com">jaemo<span>&#46;</span>lihm<span>&#64;</span>gmail<span>&#46;</span>com</a>) and Minsu Ghim (<a class="reference external" href="mailto:minsu&#46;ghim&#46;physics&#37;&#52;&#48;gmail&#46;com">minsu<span>&#46;</span>ghim<span>&#46;</span>physics<span>&#64;</span>gmail<span>&#46;</span>com</a>)</p>
<p>In this tutorial, we calculate the spin Berry curvature and the spin Hall conductivity of bcc Platinum. We compare the two methods for calculating the spin velocity matrix, which we call the “Qiao” method [1] and the “Ryoo” method [2].</p>
<p>[1] <a class="reference external" href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.98.214402">J. Qiao et al, Phys. Rev. B 98, 214402 (2018)</a> [2] <a class="reference external" href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.99.235113">J. H. Ryoo et al, Phys. Rev. B 99, 235113 (2019)</a></p>
<p>Both methods use the Kubo formula to calculate spin Hall conductivity under time-reversal symmetry:</p>
<p><span class="math">\begin{equation}
\sigma^{{\rm SHC}, \gamma}_{\alpha\beta} = \frac{-e\hbar}{N_k V_c}\sum_{\bf k}\sum_{n,m}\left(f_{n{\bf k}}-f_{m{\bf k}}\right)\frac{\textrm{Im}\left[\langle\psi_{n{\bf k}}\vert \frac{1}{2}\{ s^{\gamma}, v_\alpha \} \vert\psi_{m{\bf k}}\rangle\langle\psi_{m{\bf k}}\vert v_\beta\vert\psi_{n{\bf k}}\rangle\right]}{(\varepsilon_{n{\bf k}}-\varepsilon_{m{\bf k}})^2-(\hbar\omega+i\eta)^2}\,,
\label{eq:shc}\tag{1}
\end{equation}</span></p>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(\beta\)</span>, <span class="math notranslate nohighlight">\(\gamma\)</span> are respectively the direction of spin current, applied electric field, and spin polarisation.</p>
<p>The “Ryoo” method requires <code class="docutils literal notranslate"><span class="pre">.chk</span></code>, <code class="docutils literal notranslate"><span class="pre">.eig</span></code>, <code class="docutils literal notranslate"><span class="pre">.mmn</span></code>, <code class="docutils literal notranslate"><span class="pre">.spn</span></code>, <code class="docutils literal notranslate"><span class="pre">.sHu</span></code>, and <code class="docutils literal notranslate"><span class="pre">.sIu</span></code> files to calculate the spin velocity matrix in (<span class="math">\ref{eq:shc}</span>), <span class="math notranslate nohighlight">\(\langle\psi_{n{\bf k}}\vert \frac{1}{2}\{ s^{\gamma}, v_\alpha \} \vert\psi_{m{\bf k}}\rangle\)</span>,from pw2wannier90.x, while the “Qiao” method does not use the last two files, and instead applies an approximation <span class="math notranslate nohighlight">\(\mathbf{1}=\sum_{l\in \it{ab\,initio}} \vert u_{l{\bf q}}\rangle\langle u_{l{\bf q}}\vert\)</span>. The <code class="docutils literal notranslate"><span class="pre">sHu</span></code>
and <code class="docutils literal notranslate"><span class="pre">sIu</span></code> files are calculated by setting <code class="docutils literal notranslate"><span class="pre">write_sHu</span> <span class="pre">=</span> <span class="pre">.true.</span></code> and <code class="docutils literal notranslate"><span class="pre">write_sIu</span> <span class="pre">=</span> <span class="pre">.true.</span></code> to the <code class="docutils literal notranslate"><span class="pre">pw2wannier90.x</span></code> input file: see <code class="docutils literal notranslate"><span class="pre">data_Pt/pw2wan.in</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># Preliminary (Do only once)
%load_ext autoreload
%autoreload 2

# Set environment variables - not mandatory but recommended
import os
os.environ[&#39;OPENBLAS_NUM_THREADS&#39;] = &#39;1&#39;
os.environ[&#39;MKL_NUM_THREADS&#39;] = &#39;1&#39;


import wannierberri as wberri
import numpy as np
import scipy
import matplotlib.pyplot as plt

#  This block is needed if you run this cell for a second time
#  because one cannot initiate two parallel environments at a time
try:
    parallel.shutdown()
except NameError:
    pass

parallel = wberri.Parallel(num_cpus=4, progress_step_percent=10)
</pre></div>
</div>
</div>
<section id="Model,-band-structure">
<h2>Model, band structure<a class="headerlink" href="#Model,-band-structure" title="Link to this heading"></a></h2>
<p>We load the system from a Wannier90 output. Note the arguments <code class="docutils literal notranslate"><span class="pre">SHCryoo=True</span></code> and <code class="docutils literal notranslate"><span class="pre">SHCqiao=True</span></code> which are required to compute spin Hall conductivity using the Ryoo and Qiao methods, respectively.</p>
<p>We set symmetry using the <code class="docutils literal notranslate"><span class="pre">set_symmetry_from_structure</span></code> method, which calls spglib to automatically determine the symmetry of the system.</p>
<!-- We also symmetrize the system. See `data_Pt/Pt.win` file and check that the initial projections are correct. For details, refer to the symmetrization tutorial. --><div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>system = wberri.System_w90(&quot;data_Pt/Pt&quot;, berry=True, SHCryoo=True, SHCqiao=True)
system.set_structure([[0., 0., 0.]], [&quot;Pt&quot;])
system.set_symmetry_from_structure()

efermi = 18.1605
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>path = wberri.Path(
    system,
    nodes=[
        [0.25, 0.75, 0.50], # W
        [0.50, 0.50, 0.50], # L
        [0.00, 0.00, 0.00], # Gamma
        [0.50, 0.00, 0.50], # X
        [0.50, 0.25, 0.75], # W
        [0.00, 0.00, 0.00], # Gamma
    ],
    labels=[&quot;W&quot;, &quot;L&quot;, &quot;$\Gamma$&quot;, &quot;X&quot;, &quot;W&quot;, &quot;$\Gamma$&quot;],
    length=300,
)

from wannierberri import calculators as calc
calculators = {}
calculators[&quot;tabulate&quot;] = calc.TabulatorAll(
    {&quot;Energy&quot;: calc.tabulate.Energy()},
    ibands=np.arange(system.num_wann),
    mode=&quot;path&quot;,
)

path_result = wberri.run(
    system,
    grid=path,
    calculators=calculators,
    parallel=parallel,
    print_Kpoints = False,
)
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = path_result.results[&quot;tabulate&quot;].plot_path_fat(path, close_fig=False, show_fig=False)

ax = fig.get_axes()[0]
ax.axhline(efermi, c=&quot;r&quot;, ls=&quot;--&quot;)
plt.show(fig)
</pre></div>
</div>
</div>
<section id="Static-spin-Hall-conductivity">
<h3>Static spin Hall conductivity<a class="headerlink" href="#Static-spin-Hall-conductivity" title="Link to this heading"></a></h3>
<p>We calculate the static (i.e. DC) spin Hall conductivity. We fix <span class="math notranslate nohighlight">\(\omega\)</span> to 0 and scan the Fermi energy.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from wannierberri import calculators as calc

efermi_list = np.linspace(efermi - 1.0, efermi + 1.0, 101, True)

kwargs = dict(
    Efermi=efermi_list,
    omega=np.array([0.]),
    smr_fixed_width = 0.1, # Smearing for frequency in eV
    kBT = 0.026, # Smearing for Fermi level (Fermi-Dirac factor) in eV (not Kelvin)
)

calculators = dict(
    SHC_ryoo = calc.dynamic.SHC(SHC_type=&quot;ryoo&quot;, **kwargs),
    SHC_qiao = calc.dynamic.SHC(SHC_type=&quot;qiao&quot;, **kwargs),
)
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>nk = 30
grid = wberri.Grid(system, NK=nk)
result = wberri.run(
    system,
    grid=grid,
    calculators=calculators,
    parallel=parallel,
    print_Kpoints = False,
)
</pre></div>
</div>
</div>
<p>The SHC data has 5 indices:</p>
<ol class="arabic simple">
<li><p>The Fermi level index,</p></li>
<li><p>The frequency index,</p></li>
<li><p>The spin current direction index,</p></li>
<li><p>The electric field direction index, and</p></li>
<li><p>The spin polarization index.</p></li>
</ol>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(&quot;result.results[\&quot;SHC_ryoo\&quot;].data.shape = &quot;, result.results[&quot;SHC_ryoo&quot;].data.shape)
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print (result.results[&quot;SHC_ryoo&quot;].data.shape)
print (result.results[&quot;SHC_qiao&quot;].data.shape)
shc_ryoo = result.results[&quot;SHC_ryoo&quot;].data[:, 0,  0, 1, 2]
shc_qiao = result.results[&quot;SHC_qiao&quot;].data[:, 0, 0, 1, 2]

fig, axes = plt.subplots(1, 2, figsize=(12, 4))
axes[0].plot(omega, shc_ryoo.real, label=&quot;Ryoo&quot;)
axes[0].plot(omega, shc_qiao.real, label=&quot;Qiao&quot;)
axes[1].plot(omega, shc_ryoo.imag)
axes[1].plot(omega, shc_qiao.imag)
for ax in axes:
    ax.set_xlabel(&quot;omega (eV)&quot;)
    ax.axhline(0, c=&quot;k&quot;)
axes[0].set_ylabel(&quot;Re(SHC)&quot;)
axes[1].set_ylabel(&quot;Im(SHC)&quot;)
axes[0].legend()
plt.show()
</pre></div>
</div>
</div>
</section>
<section id="Dynamic-spin-Hall-conductivity">
<h3>Dynamic spin Hall conductivity<a class="headerlink" href="#Dynamic-spin-Hall-conductivity" title="Link to this heading"></a></h3>
<p>We calculate the dynamic (i.e. frequency-dependent, AC) spin Hall conductivity. We fix the Fermi energy to the value <code class="docutils literal notranslate"><span class="pre">efermi</span></code> and scan the frequency in the range <code class="docutils literal notranslate"><span class="pre">omega</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">smr_fixed_width</span></code> parameter controls the smearing of the frequency-dependent terms (delta functions and principal values).</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from wannierberri import calculators as calc

omega = np.linspace(0, 4, 101, True)

kwargs = dict(
    Efermi=np.array([efermi]),
    omega=omega,
    smr_fixed_width = 0.1, # Smearing for frequency in eV
    kBT = 0.026, # Smearing for Fermi level (Fermi-Dirac factor)
)

calculators = dict(
    SHC_ryoo = calc.dynamic.SHC(SHC_type=&quot;ryoo&quot;, **kwargs),
    SHC_qiao = calc.dynamic.SHC(SHC_type=&quot;qiao&quot;, **kwargs),
)
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>nk = 30
grid = wberri.Grid(system, NK=nk)
result = wberri.run(
    system,
    grid=grid,
    calculators=calculators,
    parallel=parallel,
    print_Kpoints = False,
)
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>shc_ryoo = result.results[&quot;SHC_ryoo&quot;].data[0, :, 0, 1, 2]
shc_qiao = result.results[&quot;SHC_qiao&quot;].data[0, :, 0, 1, 2]

fig, axes = plt.subplots(1, 2, figsize=(12, 4))
axes[0].plot(omega, shc_ryoo.real, label=&quot;Ryoo&quot;)
axes[0].plot(omega, shc_qiao.real, label=&quot;Qiao&quot;)
axes[1].plot(omega, shc_ryoo.imag)
axes[1].plot(omega, shc_qiao.imag)
for ax in axes:
    ax.set_xlabel(&quot;omega (eV)&quot;)
    ax.axhline(0, c=&quot;k&quot;)
axes[0].set_ylabel(&quot;Re(SHC)&quot;)
axes[1].set_ylabel(&quot;Im(SHC)&quot;)
axes[0].legend()
plt.show()
</pre></div>
</div>
</div>
</section>
<section id="Spin-Berry-curvature">
<h3>Spin Berry curvature<a class="headerlink" href="#Spin-Berry-curvature" title="Link to this heading"></a></h3>
<p>To understand the microscopic origin of the spin Hall conductivity, one may inspect the k-resolved spin Berry curvature. Eq. (<span class="math">\ref{eq:shc}</span>) is recast into the sum of a Berry-curvature-like term, the spin Berry curvature.</p>
<p>The spin Berry curvature is</p>
<dl class="simple">
<dt>:nbsphinx-math:<a href="#id1"><span class="problematic" id="id2">`</span></a>begin{equation}</dt><dd><p>Omega^{n, gamma}_{alphabeta}({bf k}) = -sum_{m neq n}frac{2textrm{Im}left[langlepsi_{n{bf k}}vert frac{1}{2}{ s^{gamma}, <a href="#id11"><span class="problematic" id="id12">v_</span></a>alpha } vertpsi_{m{bf k}}ranglelanglepsi_{m{bf k}}vert <a href="#id13"><span class="problematic" id="id14">v_</span></a>betavertpsi_{n{bf k}}rangleright]}{(varepsilon_{n{bf k}}-varepsilon_{m{bf k}})^2-(ieta)^2},,
label{eq:sbc}tag{2}</p>
</dd>
</dl>
<p>end{equation}`</p>
<p>and the k-resolved spin Berry curvature summed over the band index is</p>
<dl class="simple">
<dt>:nbsphinx-math:<a href="#id3"><span class="problematic" id="id4">`</span></a>begin{equation}</dt><dd><p>Omega^{gamma}_{alphabeta}({bf k}) = sum_{n}f_{n{bf k}}Omega^{n, gamma}_{alphabeta}({bf k}),.
label{eq:sbc_k_resolved}tag{3}</p>
</dd>
<dt>end{equation}` :nbsphinx-math:<a href="#id5"><span class="problematic" id="id6">`</span></a>begin{equation}</dt><dd><p>sigma^{{rm SHC}, gamma}_{alphabeta} = frac{-ehbar}{N_kOmega_c}sum_{bf k}Omega^{gamma}_{alphabeta}({bf k})
label{eq:shc_sbc}tag{4}</p>
</dd>
</dl>
<p>end{equation}`</p>
<p>Therefore, where in the k-space contributes to the total SHC can be investigated using the k-resolved spin Berry curvature.</p>
<p>Here, we compute the spin Berry curvature again using the Ryoo method and the Qiao method. Note that we pass the spin curren type as a <code class="docutils literal notranslate"><span class="pre">kwargs_formula</span></code> to the calculator, e.g. <code class="docutils literal notranslate"><span class="pre">kwargs_formula=dict(spin_current_type=&quot;ryoo&quot;)</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from wannierberri import calculators as calc
calculators = {}
calculators[&quot;tabulate&quot;] = calc.TabulatorAll(
     {
         &quot;Energy&quot;: calc.tabulate.Energy(),
         &#39;spin_berry_ryoo&#39;: calc.tabulate.SpinBerry(kwargs_formula=dict(spin_current_type=&quot;ryoo&quot;), degen_thresh=1e-2),
         &#39;spin_berry_qiao&#39;: calc.tabulate.SpinBerry(kwargs_formula=dict(spin_current_type=&quot;qiao&quot;), degen_thresh=1e-2),
     },
    ibands=np.arange(system.num_wann),
    mode=&quot;path&quot;,
 )
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>path = wberri.Path(
    system,
    k_nodes=[
        [0.25, 0.75, 0.50], # W
        [0.50, 0.50, 0.50], # L
        [0.00, 0.00, 0.00], # Gamma
        [0.50, 0.00, 0.50], # X
        [0.50, 0.25, 0.75], # W
        [0.00, 0.00, 0.00], # Gamma
    ],
    labels=[&quot;W&quot;, &quot;L&quot;, &quot;$\Gamma$&quot;, &quot;X&quot;, &quot;W&quot;, &quot;$\Gamma$&quot;],
    length=600,
)

result_spin_berry = wberri.run(
    system,
    grid=path,
    calculators=calculators,
    parallel = parallel,
    print_Kpoints = False,
)
</pre></div>
</div>
</div>
<p>Now we sum over bands to compute the k-resolved spin Berry curvature:</p>
<div class="math notranslate nohighlight">
\[\Omega^{\gamma}_{\alpha\beta}({\bf k}) = \sum_{n \in {\rm occ.}} \Omega^{n, \gamma}_{\alpha\beta}({\bf k})\]</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>nk = path.K_list.shape[0]
spin_berry_ryoo = np.zeros((nk, 3, 3, 3))
spin_berry_qiao = np.zeros((nk, 3, 3, 3))

for iband in range(system.num_wann):
    # Get the data for iband-th band
    e = result_spin_berry.results[&quot;tabulate&quot;].get_data(&quot;Energy&quot;, iband)
    spin_berry_ryoo_nk = result_spin_berry.results[&quot;tabulate&quot;].get_data(&quot;spin_berry_ryoo&quot;, iband)
    spin_berry_qiao_nk = result_spin_berry.results[&quot;tabulate&quot;].get_data(&quot;spin_berry_qiao&quot;, iband)

    # Select k-point indices where the iband-th band is occupied
    inds_occupied = e &lt; efermi

    # Add the spin Berry curvature of those bands
    spin_berry_ryoo[inds_occupied] += spin_berry_ryoo_nk[inds_occupied]
    spin_berry_qiao[inds_occupied] += spin_berry_qiao_nk[inds_occupied]
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def get_signed_log10(x):
    return np.log10(abs(x)) * np.sign(x)

kline = path.getKline()
plt.plot(kline, get_signed_log10(spin_berry_ryoo[:, 0, 1, 2]), &quot;k-&quot;, label=&#39;Ryoo&#39;)
plt.plot(kline, get_signed_log10(spin_berry_qiao[:, 0, 1, 2]), &quot;r--&quot;, label=&#39;Qiao&#39;)

for i in path.labels.keys():
    plt.axvline(kline[i], c=&quot;k&quot;, lw=1)
plt.xticks([kline[i] for i in path.labels.keys()], path.labels.values())
plt.xlim([min(kline), max(kline)])
plt.axhline(0, c=&quot;k&quot;, lw=1)
plt.legend()
plt.title(&quot;$\mathrm{log}_{10} \Omega_\mathbf{k}$&quot;)

plt.show()
</pre></div>
</div>
</div>
<p>You can find that the spin Berry curvature calculated using the Qiao method shows more “wiggles” than the Ryoo method. This numerical difference has been first reported in <a class="reference external" href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.104.014412">T. Ng et al, PRB 104 014412 (2021)</a>:</p>
<blockquote>
<div><p>It is worth noting that there is jittering along Γ-Z, which occurs in the same path in WTe2 using the same method [22] (Qiao et al). However, such jittering disappears and the spin Berry curvature along Γ-Z becomes a smooth function using the method in Ref. [45] (Ryoo et al).</p>
</div></blockquote>
</section>
<section id="Generating-.sHu-and-.sIu-from-.mmn-and-.spn:-mmn2uHu">
<h3>Generating .sHu and .sIu from .mmn and .spn: mmn2uHu<a class="headerlink" href="#Generating-.sHu-and-.sIu-from-.mmn-and-.spn:-mmn2uHu" title="Link to this heading"></a></h3>
<p>Even if you have not obtained .shu and .sIu from an ab initio code, you can make them from the overlap matrix and the spin matrix. Wannierberri provides the utility <code class="docutils literal notranslate"><span class="pre">wannierberri.utils.mmn2uHu</span></code>, which calculated the matrices <code class="docutils literal notranslate"><span class="pre">.uHu</span></code>, <code class="docutils literal notranslate"><span class="pre">.uIu</span></code>, <code class="docutils literal notranslate"><span class="pre">.sHu</span></code>, and/or <code class="docutils literal notranslate"><span class="pre">.sIu</span></code> from the <code class="docutils literal notranslate"><span class="pre">.mmn</span></code>, <code class="docutils literal notranslate"><span class="pre">.spn</span></code>, <code class="docutils literal notranslate"><span class="pre">.eig</span></code> matrices, and also reduces the number of bands in <code class="docutils literal notranslate"><span class="pre">.amn</span></code>, <code class="docutils literal notranslate"><span class="pre">.mmn</span></code>, <code class="docutils literal notranslate"><span class="pre">.eig</span></code> and <code class="docutils literal notranslate"><span class="pre">.spn</span></code> files, by means of the sum-over-states formula</p>
<dl class="simple">
<dt>:nbsphinx-math:<a href="#id7"><span class="problematic" id="id8">`</span></a>begin{equation}</dt><dd><p>langle u_{m{bf q}}verthat{s}hat{H}_{bf q}vert u_{n{bf q}+mathbf{b}}rangle approx sum_l^{l_{rm max}}  left(s_{lm}({bf q})right)^* E_{l{bf q}}   M_{ln}^{mathbf{b}}({bf q}),.</p>
</dd>
</dl>
<p>label{eq:sHu}tag{5}
end{equation}`</p>
<dl class="simple">
<dt>:nbsphinx-math:<a href="#id9"><span class="problematic" id="id10">`</span></a>begin{equation}</dt><dd><p>langle u_{m{bf q}}verthat{s}vert u_{n{bf q}+mathbf{b}}rangle approx sum_l^{l_{rm max}}  left(s_{lm}({bf q})right)^*   M_{ln}^{mathbf{b}}({bf q}),.</p>
</dd>
</dl>
<p>label{eq:sIu}tag{6}
end{equation}`</p>
<p>Here, <span class="math notranslate nohighlight">\(l_{\rm max}\)</span> cannot exceed the number of bands included in the Wannier90 calculation (i.e. the <code class="docutils literal notranslate"><span class="pre">num_bands</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">Pt.win</span></code>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">mmn2uHu</span></code> utility can be particularly useful when the calculation of <code class="docutils literal notranslate"><span class="pre">sHu</span></code> and <code class="docutils literal notranslate"><span class="pre">sIu</span></code> files are not implemented in the DFT code you are using.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from wannierberri.utils import mmn2uHu as mmn2uHu
os.chdir(&quot;data_Pt&quot;)
mmn2uHu.run_mmn2uHu(PREFIX=&quot;Pt&quot;, writeSHU=True, writeSIU=True, NBout=18, NBsum=24)

# For a command-line execution of the mmn2uHu utility, use
# python3 -m wannierberri.utils.mmn2uHu Pt NBout=18,NBsum=24,targets=sHu,sIu

# Rename sHu and sIu files
import shutil
shutil.move(&quot;reduced_NB=24/Pt_nbs=24.sHu&quot;, &quot;reduced_NB=24/Pt.sHu&quot;)
shutil.move(&quot;reduced_NB=24/Pt_nbs=24.sIu&quot;, &quot;reduced_NB=24/Pt.sIu&quot;)

# Copy chk and spn files
shutil.copyfile(&quot;Pt.chk&quot;, &quot;reduced_NB=24/Pt.chk&quot;)
shutil.copyfile(&quot;Pt.spn&quot;, &quot;reduced_NB=24/Pt.spn&quot;)

os.chdir(&quot;..&quot;)
</pre></div>
</div>
</div>
<p>Now, load the system object. Since all the data are in the <code class="docutils literal notranslate"><span class="pre">data_Pt/reduced_NB=24</span></code> directory, you should use the seedname <code class="docutils literal notranslate"><span class="pre">data_Pt/reduced_NB=24/Pt</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>system_mmn2uhu = wberri.System_w90(&quot;data_Pt/reduced_NB=24/Pt&quot;, berry=True, SHCryoo=True, SHCqiao=True)
system_mmn2uhu.set_structure([[0., 0., 0.]], [&quot;Pt&quot;])
system_mmn2uhu.set_symmetry_from_structure()
</pre></div>
</div>
</div>
</section>
</section>
<section id="Problem:-Compare-the-SHC-computed-using-the-sHu-files-from-pw2wannier90-and-mmn2uHu.">
<h2>Problem: Compare the SHC computed using the sHu files from pw2wannier90 and mmn2uHu.<a class="headerlink" href="#Problem:-Compare-the-SHC-computed-using-the-sHu-files-from-pw2wannier90-and-mmn2uHu." title="Link to this heading"></a></h2>
<p>Compute the SHC using <code class="docutils literal notranslate"><span class="pre">system</span></code> and <code class="docutils literal notranslate"><span class="pre">system_mmn2uHu</span></code>. Since the “Qiao” method does not use the sHu and sIu files, the two systems will give exactly the same result. This may not be the case for the “Ryoo” method.</p>
<p>Use the keyword arguments given below (Fermi level scan at 0.026 meV ~ 300 K).</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>efermi_list = np.linspace(efermi - 1.0, efermi + 1.0, 101, True)

kwargs = dict(
    Efermi=efermi_list,
    omega=np.array([0.]),
    smr_fixed_width = 0.1, # Smearing for frequency in eV
    kBT = 0.026, # Smearing for Fermi level (Fermi-Dirac factor) in eV (not Kelvin)
)

# Fill in the code below.
</pre></div>
</div>
</div>
<section id="Further-questions">
<h3>Further questions<a class="headerlink" href="#Further-questions" title="Link to this heading"></a></h3>
<p>If you are interested, try to answer the following questions:</p>
<ul class="simple">
<li><p>Try to converge the calculation using a different value of <code class="docutils literal notranslate"><span class="pre">smr_fixed_width</span></code>. In principle, to achieve an ideal convergence to the zero-smearing limit, one needs to first converge SHC increasing the grid size for a fixed <code class="docutils literal notranslate"><span class="pre">smr_fixed_width</span></code>, and then repeat the procedure with smaller <code class="docutils literal notranslate"><span class="pre">smr_fixed_width</span></code> until convergence.</p></li>
<li><p>What happens if one include more bands in the NSCF calculation? Does the two methods converge to the same result? (To answer this question, one needs to perform additional DFT calculations.)</p></li>
</ul>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Stepan Tsirkin.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>